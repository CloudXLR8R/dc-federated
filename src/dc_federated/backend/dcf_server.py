"""
Defines the core server class for the federated learning.
Abstracts away the lower level server logic from the federated
machine learning logic.
"""
import gevent
from gevent import monkey; monkey.patch_all()
from gevent import Greenlet, queue

import os
import json
import pickle
import hashlib
import time
import os.path
import zlib

from nacl.signing import VerifyKey
from nacl.encoding import HexEncoder
from nacl.exceptions import BadSignatureError

import bottle
from bottle import Bottle, run, request, response, auth_basic, ServerAdapter

from dc_federated.backend._constants import *
from dc_federated.backend.backend_utils import *
from dc_federated.utils import get_host_ip
from dc_federated.backend.backend_utils import is_valid_model_dict


import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
logger.setLevel(level=logging.INFO)


class DCFServer(object):
    """
    This class abstracts away the lower level communication logic for
    the central server/node from the actual federated learning logic.
    It interacts with the central server node via the 4 callback functions
    passed in the constructor. For an example usage please refer to the
    package dc_federated.example_dcf+model.

    Parameters
    ----------

        register_worker_callback:
            This function is expected to take the id of a newly registered
            worker and should contain the application specific logic for
            dealing with a new worker joining the federated learning pool.

        unregister_worker_callback:
            This function is expected to take the id of a newly unregistered
            worker and should contain the application specific logic for
            dealing with a worker leaving the federated learning pool.

        return_global_model_callback: () -> dict
            This function is expected to return a dictionary with the
            GLOBAL_MODEL: containing the serialization of the global model
            GLOBAL_MODEL_VERSION: containing the global model itself.

        is_global_model_most_recent:  str -> bool
            Returns the True if the model version given in the string is the
            most recent one - otherwise returns False.

        receive_worker_update_callback: dict -> bool
            This function should receive a worker-id and an application
            dependent binary serialized update from the worker. The
            server code ensures that the worker-id was previously
            registered.

        server_mode_safe: bool
            Whether or not the server should be in safe of unsafe mode. Safe
            does not allow unauthenticated workers with the optional initial
            set of public keys passed via the key_list_parameters. Raises
            an exception if server started in unsafe mode and key_list_file
            is not None.

        key_list_file: str
            The name of the file containing the public keys for valid workers.
            The public keys are given one key per line, with each key being
            generated by the worker_key_pair_tool.py tool. If None, then
            no authentication is performed.

        server_host_ip: str (default None)
            The ip-address of the host of the server. If None, then it
            uses the ip-address of the current machine.

        server_port: int (default 8080)
            The port at which the serer should listen to. If None, then it
            uses the port 8080.

        ssl_enabled: bool (default False)
            Enable SSL/TLS for server/workers communications.

        ssl_keyfile: str
            Must be a valid path to the key file.
            This is mandatory if ssl_enabled, ignored otherwise.

        ssl_certfile: str
            Must be a valid path to the certificate.
            This is mandatory if ssl_enabled, ignored otherwise.

        model_check_interval: int
            The interval of time between the server checking for an updated
            model for the long polling.
    """
    def __init__(
        self,
        register_worker_callback,
        unregister_worker_callback,
        return_global_model_callback,
        is_global_model_most_recent,
        receive_worker_update_callback,
        server_mode_safe,
        key_list_file,
        server_host_ip=None,
        server_port=8080,
        ssl_enabled=False,
        ssl_keyfile=None,
        ssl_certfile=None,
        model_check_interval=10,
        debug=False):
        self.server_host_ip = get_host_ip() if server_host_ip is None else server_host_ip
        self.server_port = server_port

        self.register_worker_callback = register_worker_callback
        self.unregister_worker_callback = unregister_worker_callback
        self.return_global_model_callback = return_global_model_callback
        self.is_global_model_most_recent = is_global_model_most_recent
        self.receive_worker_update_callback = receive_worker_update_callback

        self.worker_authenticator = WorkerAuthenticator(server_mode_safe, key_list_file)
        self.model_check_interval = model_check_interval
        self.debug = debug

        self.allowed_workers = self.worker_authenticator.get_keys()
        self.registered_workers = set()
        self.last_worker = -1
        self.ssl_enabled = ssl_enabled

        if ssl_enabled:
            if ssl_certfile is None or ssl_keyfile is None:
                raise RuntimeError(
                    "When ssl is enabled, both a certfile and keyfile must be provided")
            if not os.path.isfile(ssl_certfile):
                raise IOError(
                    "The provided SSL certificate file doesn't exist")
            if not os.path.isfile(ssl_keyfile):
                raise IOError("The provided SSL key file doesn't exist")
            self.ssl_keyfile = ssl_keyfile
            self.ssl_certfile = ssl_certfile

    def is_admin(self, username, password):
        """
        Callback for bottle to check that the requester is authorized to
        act as an admin for the server.

        Parameters
        ----------
        username: str
            The admin username.

        password: str
            The admin password.

        Returns
        -------

        bool:
            True if the user/password us valid, false otherwise.
        """
        adm_username = os.environ.get(ADMIN_USERNAME)
        adm_password = os.environ.get(ADMIN_PASSWORD)

        if adm_username is None or adm_password is None:
            return False

        return username == adm_username and password == adm_password

    def register_worker(self):
        """
        Authenticates the worker

        Returns
        -------

        int:
            The id of the new client.
        """
        worker_data = request.json

        auth_success, auth_type = \
            self.worker_authenticator.authenticate_worker(worker_data[PUBLIC_KEY_STR],
                                                          worker_data[SIGNED_PHRASE])
        if auth_success:
            worker_id = self.worker_authenticator.generate_id_for_worker(worker_data[PUBLIC_KEY_STR])
            if worker_id not in self.allowed_workers:
                self.allowed_workers.append(worker_id)
            if worker_id not in self.registered_workers:
                self.registered_workers.add(worker_id)
                self.register_worker_callback(worker_id)
            logger.info(
                f"Successfully registered worker with public key: {worker_data[PUBLIC_KEY_STR]}")
        else:
            logger.info(
                f"Failed to register worker with public key: {worker_data[PUBLIC_KEY_STR]}")
            worker_id = INVALID_WORKER

        return worker_id

    def admin_list_workers(self):
        """
        List all registered workers

        Returns
        -------

        [string]:
            The id of the workers
        """
        response.content_type = 'application/json'
        return json.dumps([{WORKER_ID_KEY: worker_id, REGISTRATION_STATUS_KEY: worker_id in self.registered_workers}
                           for worker_id in self.allowed_workers])

    def admin_add_worker(self):
        """
        Add a new worker to the list or allowed workers

        JSON Body:
            public_key_str: string The public key associated with the worker

        Returns
        -------

        str:
            The new worker id
        """
        response.content_type = 'application/json'
        worker_data = request.json

        if worker_data is None or not isinstance(worker_data, dict):
            error_str = "Failed to add worker - data sent was not in valid JSON format."
            logger.error(error_str)
            return json.dumps({
                ERROR_MESSAGE_KEY: error_str
            })

        logger.info("Admin is adding a new worker...")

        if PUBLIC_KEY_STR not in worker_data:
            logger.error(f"Public key was not not passed in {worker_data} "
                         f"using the key '{PUBLIC_KEY_STR}'.")
            return json.dumps({
                ERROR_MESSAGE_KEY: "Public key was not not passed in input "
                         f"using the key '{PUBLIC_KEY_STR}'."
            })

        worker_id = self.worker_authenticator.generate_id_for_worker(worker_data[PUBLIC_KEY_STR])
        logger.info(f"Worker id is {worker_id}")

        if not isinstance(worker_id, str) or not len(worker_id):
            logger.error(f"Public key should be a string: {worker_id}")
            return json.dumps({
                ERROR_MESSAGE_KEY: "Public key must be a string"
            })

        if worker_id in self.allowed_workers:
            logger.warning(f"Worker {worker_id} already exists")
            return json.dumps({
                ERROR_MESSAGE_KEY: f"Worker {worker_id} already exists"
            })

        if not self.worker_authenticator.add_worker(worker_id):
            error_msg = f"Unable to create valid public key with {worker_id} -- worker not added."
            logger.error(error_msg)
            return json.dumps({ ERROR_MESSAGE_KEY: error_msg })

        self.allowed_workers.append(worker_id)

        logger.info(f"Worker {worker_id} was added")

        if REGISTRATION_STATUS_KEY in worker_data and worker_data[REGISTRATION_STATUS_KEY]:
            self.registered_workers.add(worker_id)
            self.register_worker_callback(worker_id)
            logger.info(f"Worker {worker_id} was registered")

        return json.dumps({
            WORKER_ID_KEY: worker_id,
            REGISTRATION_STATUS_KEY: worker_id in self.registered_workers
        })

    def admin_delete_worker(self, worker_id):
        """
        Allow admin to delete a worker given its id

        Parameters
        ----------

        worker_id: str
            The id of the worker to delete

        Returns
        -------

        str:
            Id of worker removed or error message if worker was removed
            or an error message.

        """
        logger.info(f"Admin is removing worker {worker_id}...")

        if worker_id in self.registered_workers:
            self.registered_workers.remove(worker_id)
            self.unregister_worker_callback(worker_id)
            logger.info(f"Worker {worker_id} was unregistered (removal)")

        if worker_id in self.allowed_workers:
            self.allowed_workers.remove(worker_id)
            self.worker_authenticator.delete_worker(worker_id)

            # TODO callback for worker removed?
            logger.info(f"Worker {worker_id} was removed")
        else:
            logger.warning(f"Attempt to remove unknown worker {worker_id}.")
            return json.dumps({
                ERROR_MESSAGE_KEY: f"Attempt to remove unknown worker {worker_id}."
            })

        return json.dumps({
                SUCCESS_MESSAGE_KEY: f"Successfully removed worker {worker_id}."
            })

    def admin_set_worker_status(self, worker_id):
        """
        Allow admin to change status (REGISTRATION_STATUS_KEY = True or False)
        of a given worker.

        Parameters
        ----------

        worker_id: str
            The id of the worker to set the status for.

        Returns
        -------

        str:
            JSON string of error Or success message

        """
        worker_data = request.json

        logger.info(f"Admin is setting the status of {worker_id}...")

        if REGISTRATION_STATUS_KEY not in worker_data:
            logger.error(f"The status was not not passed in {worker_data}")
            return json.dumps({
                ERROR_MESSAGE_KEY: f"Key '{REGISTRATION_STATUS_KEY}' is missing in payload"
            })

        should_register = worker_data[REGISTRATION_STATUS_KEY]
        logger.info(f"New {worker_id} status is {REGISTRATION_STATUS_KEY}: {should_register}")

        if not isinstance(should_register, bool):
            logger.error(f"Key '{REGISTRATION_STATUS_KEY}' should be a boolean: {should_register}")
            return json.dumps({
                ERROR_MESSAGE_KEY: f"Key '{REGISTRATION_STATUS_KEY}' should be a boolean: {should_register}"
            })

        if worker_id not in self.allowed_workers:
            logger.error(f"Unknown worker: {worker_id}")
            return json.dumps({
                ERROR_MESSAGE_KEY: f"Unknown worker: {worker_id}"
            })

        was_registered = worker_id in self.registered_workers
        if should_register and not was_registered:
            self.registered_workers.add(worker_id)
            logger.info(f"Worker {worker_id} was registered")
            self.register_worker_callback(worker_id)
        elif not should_register and was_registered:
            self.registered_workers.remove(worker_id)
            logger.info(f"Worker {worker_id} was unregistered")
            self.unregister_worker_callback(worker_id)
        else:
            logger.warning(f"Nothing to change for {worker_id}")

        return json.dumps({
            SUCCESS_MESSAGE_KEY:f"Successfully changed status for worker {worker_id}.",
            WORKER_ID_KEY: worker_id,
            REGISTRATION_STATUS_KEY: should_register
        })

    def receive_worker_update(self, worker_id):
        """
        This receives the update from a worker and calls the corresponding callback function.
        Expects that the worker_id and model-update were sent using the DCFWorker.send_model_update()

        Returns
        -------

        str:
            If the update was successful then "Worker update received"
            Otherwise any exception that was raised.
        """
        try:
            model_update = zlib.decompress(
                request.files[ID_AND_MODEL_KEY].file.read())

            if worker_id not in self.allowed_workers:
                logger.warning(
                    f"Unknown worker {worker_id} tried to send an update.")
                return UNREGISTERED_WORKER

            if worker_id not in self.registered_workers:
                logger.warning(
                    f"Unregistered worker {worker_id} tried to send an update.")
                return UNREGISTERED_WORKER

            return self.receive_worker_update_callback(worker_id, model_update)

        except Exception as e:
            logger.warning(e)
            return str(e)

    def check_model_ready(self, body, last_worker_model_version):
        """
        Threaded function run to check with the server if the model is ready.

        Parameters
        ---------

        body: gevent.queue.Queue
            The Queue used to return the data to the calling worker and
            fulfill the WSGI promise/map.

       last_worker_model_version: object
            The version of the last model that the worker was using.
        """
        while self.is_global_model_most_recent(last_worker_model_version):
            gevent.sleep(self.model_check_interval)

        model_update = self.return_global_model_callback()
        if not is_valid_model_dict(model_update):
            logger.error(f"Expected dictionary with {GLOBAL_MODEL} and {GLOBAL_MODEL_VERSION} keys - "
                         "return_global_model_callback() implementation is incorrect")
        body.put(zlib.compress(pickle.dumps(model_update)))
        body.put(StopIteration)

    def return_global_model(self):
        """
        Returns the global model by using the provided callback using gevent
        based long polling. It spawns a gevent Greenlet (a pseudo-thread) for
        check_model_ready, which returns a model when ready, but otherwise
        waits.

        Returns
        -------

        gevent.queuue.Queue or str:
            The Queue object that returns the model in a long polling or
            a string indicating an error has occured.
        """
        try:
            query_request = request.json
            if WORKER_ID_KEY not in query_request:
                logger.warning(
                    f"Key {WORKER_ID_KEY} is missing in query_request.")
                return UNREGISTERED_WORKER

            worker_id = query_request[WORKER_ID_KEY]

            if worker_id not in self.allowed_workers:
                logger.warning(
                    f"Unknown worker {worker_id} tried to return global model.")
                return UNREGISTERED_WORKER

            if worker_id not in self.registered_workers:
                logger.warning(
                    f"Unregistered worker {worker_id} tried to return global model.")
                return UNREGISTERED_WORKER

            body = gevent.queue.Queue()
            g = Greenlet.spawn(self.check_model_ready, body, query_request[LAST_WORKER_MODEL_VERSION])
            return body

        except Exception as e:
            logger.warning(e)
            return str(e)

    @staticmethod
    def enable_cors():
        """
        Enable the cross origin resource for the server.
        """
        response.add_header('Access-Control-Allow-Origin', '*')
        response.add_header('Access-Control-Allow-Methods',
                            'GET, POST, PUT, OPTIONS')
        response.add_header('Access-Control-Allow-Headers',
                            'Origin, Accept, Content-Type, X-Requested-With, X-CSRF-Token')

    def start_server(self, server_adapter=None):
        """
        Sets up all the routes for the server and starts it.

        server_backend: bottle.ServerAdapter (default None)
            The server adapter to use. The default bottle.WSGIRefServer is used if none is given.
            WARNING: If given, this will over-ride the host-ip and port passed as parameters to this
            object.
        """
        application = Bottle()
        application.route(f"/{REGISTER_WORKER_ROUTE}",
                          method='POST', callback=self.register_worker)
        application.route(f"/{RETURN_GLOBAL_MODEL_ROUTE}",
                          method='POST', callback=self.return_global_model)
        application.route(f"/{RECEIVE_WORKER_UPDATE_ROUTE}/<worker_id>",
                          method='POST', callback=self.receive_worker_update)

        application.add_hook('after_request', self.enable_cors)

        # Admin routes
        application.get(
            f"/{WORKERS_ROUTE}", callback=auth_basic(self.is_admin)(self.admin_list_workers))
        application.post(
            f"/{WORKERS_ROUTE}", callback=auth_basic(self.is_admin)(self.admin_add_worker))
        application.delete(f"/{WORKERS_ROUTE}/<worker_id>",
                           callback=auth_basic(self.is_admin)(self.admin_delete_worker))
        application.put(f"/{WORKERS_ROUTE}/<worker_id>",
                        callback=auth_basic(self.is_admin)(self.admin_set_worker_status))

        if server_adapter is not None and isinstance(server_adapter, ServerAdapter):
            self.server_host_ip = server_adapter.host
            self.server_port = server_adapter.port
            run(application, server=server_adapter, debug=self.debug, quiet=True)
        elif self.ssl_enabled:
            run(application,
                host=self.server_host_ip,
                port=self.server_port,
                server='gunicorn',
                worker_class='gevent',
                keyfile=self.ssl_keyfile,
                certfile=self.ssl_certfile,
                debug=self.debug,
                quiet=True)
        else:
            run(application,
                host=self.server_host_ip,
                port=self.server_port,
                server='gunicorn',
                worker_class='gevent',
                debug=self.debug,
                quiet=True)


class WorkerAuthenticator(object):
    """
    Helper class for authenticating workers.

    Parameters
    ----------

    server_mode_safe: bool
        Whether or not the server should be in safe of unsafe mode. Safe
        does not allow unauthenticated workers with the optional initial
        set of public keys passed via the key_list_parameters. Raises
        an exception if server started in unsafe mode and key_list_file
        is not None.

    key_list_file: str
        The name of the file containing the public keys for valid workers.
        The file is a just list of the public keys, each generated by the
        worker_key_pair_tool tool. All workers are accepted if no workers
        are provided.
    """

    def __init__(self, server_mode_safe, key_list_file):
        if not server_mode_safe:
            if key_list_file is not None:
                error_str = "Server started in unsafe mode but list of public keys provided. "\
                            "Either explicitly start server in safe mode or do not " \
                            "supply a public key list."
                logger.error(error_str)
                raise ValueError(error_str)
            else:
                logger.warning(f"No key list file provided - "
                               f"no worker authentication will be used!!!.")
                logger.warning(f"Server is running in ****UNSAFE MODE.****")
                self.authenticate = False
                self.keys = {}
                return

        self.authenticate = True
        if key_list_file is not None:
            with open(key_list_file, 'r') as f:
                keys = f.read().splitlines()
            self.keys = {key: VerifyKey(
                key.encode(), encoder=HexEncoder) for key in keys}
        else:
            self.keys = {}

    def add_worker(self, public_key_str):
        """
        Adds the given worker to the internal set of workers.

        Parameters
        ----------

        public_key_str: str
            UFT-8 encoded version of the public key

        Returns
        -------
        bool: True if operation was successful false otherwise
        """
        if not self.authenticate:
            return True
        try:
            if public_key_str not in self.keys:
                self.keys[public_key_str] = VerifyKey(public_key_str.encode(), encoder=HexEncoder)
        except Exception as e:
            logger.warning(e)
            return False

        return True

    def delete_worker(self, public_key_str):
        """
        Removes the given worker to the internal set of workers.

        Parameters
        ----------

        public_key_str: str
            UFT-8 encoded version of the public key

        Returns
        -------
        bool:
            True if operation was successful false otherwise
        """
        if not self.authenticate:
            return True
        try:
            if public_key_str in self.keys:
                del self.keys[public_key_str]
        except Exception as e:
            logger.warning(e)
            return False

        return True

    def get_keys(self):
        """
        Returns the list of keys that this authenticator has.

        Returns
        --------

        list of str:
            The set of keys.
        """
        return list(self.keys.keys())

    def generate_id_for_worker(self, public_key_str):
        """
        Returns the internal id for the worker with public key =
        public_key_str. If mode is not authenticate, this will generate a new
        id for every call with the same public_key_str argument. Otherwise
        it will just return public_key_str.

        Parameters
        ----------

        public_key_str: str
            UFT-8 encoded version of the public key

        Returns
        -------

        str:
            The worker id.
        """
        if self.authenticate:
            return public_key_str
        else:
            return hashlib.sha224(str(time.time()).encode(
                    'utf-8')).hexdigest() + '_unauthenticated'


    def authenticate_worker(self, public_key_str, signed_message):
        """
        Authenticates a worker with the given public key against the
        given signed message.

        Parameters
        ----------

        public_key_str: str
            UFT-8 encoded version of the public key

        signed_message: str
            UTF-8 encoded signed message

        Returns
        -------

        bool:
            True if the public key matches the singed messge
            False otherwise
        """
        if not self.authenticate:
            logger.warning("Accepting worker as valid without authentication.")
            logger.warning(
                "Server was likely started without a list of valid public keys from workers.")
            return True, NO_AUTHENTICATION
        try:
            if public_key_str not in self.keys:
                return False, AUTHENTICATED
            self.keys[public_key_str].verify(
                signed_message.encode(), encoder=HexEncoder)
        except BadSignatureError:
            logger.warning(
                f"Failed to authenticate worker with public key: {public_key_str}.")
            return False, AUTHENTICATED
        else:
            logger.info(
                f"Successfully authenticated worker with public key: {public_key_str}.")
            return True, AUTHENTICATED
