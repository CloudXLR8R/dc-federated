"""
Defines the core server class for the federated learning.
Abstracts away the lower level server logic from the federated
machine learning logic.
"""
import gevent
from gevent import monkey; monkey.patch_all()
from gevent import Greenlet, queue

import pickle
import hashlib
import time

import os

import bottle
from bottle import request, Bottle, run
from dc_federated.backend._constants import *
from dc_federated.backend.backend_utils import *
from dc_federated.utils import get_host_ip

from nacl.signing import VerifyKey
from nacl.encoding import HexEncoder
from nacl.exceptions import BadSignatureError
from bottle import Bottle, run, request, ServerAdapter

from dc_federated.backend.backend_utils import is_valid_model_dict

import logging
import zlib

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
logger.setLevel(level=logging.INFO)


class DCFServer(object):
    """
    This class abstracts away the lower level communication logic for
    the central server/node from the actual federated learning logic.
    It interacts with the central server node via the 4 callback functions
    passed in the constructor. For an example usage please refer to the
    package dc_federated.example_dcf+model.

    Parameters
    ----------

        register_worker_callback:
            This function is expected to take the id of a newly registered
            worker and should contain the application specific logic for
            dealing with a new worker joining the federated learning pool.

        return_global_model_callback: () -> dict
            This function is expected to return a dictionary with the
            GLOBAL_MODEL: containing the serialization of the global model
            GLOBAL_MODEL_VERSION: containing the global model itself.

        is_global_model_most_recent:  str -> bool
            Returns the True if the model version given in the string is the
            most recent one - otherwise returns False.

        receive_worker_update_callback: dict -> bool
            This function should receive a worker-id and an application
            dependent binary serialized update from the worker. The
            server code ensures that the worker-id was previously
            registered.

        key_list_file: str
            The name of the file containing the public keys for valid workers.
            The public keys are given one key per line, with each key being
            generated by the worker_key_pair_tool.py tool. If None, then
            no authentication is performed.

        server_host_ip: str (default None)
            The ip-address of the host of the server. If None, then it
            uses the ip-address of the current machine.

        server_port: int (default 8080)
            The port at which the serer should listen to. If None, then it
            uses the port 8080.

        ssl_enabled: bool (default False)
            Enable SSL/TLS for server/workers communications.

        ssl_keyfile: str
            Must be a valid path to the key file.
            This is mandatory if ssl_enabled, ignored otherwise.

        ssl_certfile: str
            Must be a valid path to the certificate.
            This is mandatory if ssl_enabled, ignored otherwise.

        model_check_interval: int
            The interval of time between the server checking for an updated
            model for the long polling.
    """
    def __init__(
        self,
        register_worker_callback,
        return_global_model_callback,
        is_global_model_most_recent,
        receive_worker_update_callback,
        key_list_file,
        server_host_ip=None,
        server_port=8080,
        ssl_enabled=False,
        ssl_keyfile=None,
        ssl_certfile=None,
        model_check_interval=10,
        debug=False):
        self.server_host_ip = get_host_ip() if server_host_ip is None else server_host_ip
        self.server_port = server_port

        self.register_worker_callback = register_worker_callback
        self.return_global_model_callback = return_global_model_callback
        self.is_global_model_most_recent = is_global_model_most_recent
        self.receive_worker_update_callback = receive_worker_update_callback

        self.worker_authenticator = WorkerAuthenticator(key_list_file)
        self.model_check_interval = model_check_interval
        self.debug = debug

        self.worker_list = []
        self.last_worker = -1
        self.ssl_enabled = ssl_enabled

        if ssl_enabled:
            if ssl_certfile is None or ssl_keyfile is None:
                raise RuntimeError(
                    "When ssl is enabled, both a certfile and keyfile must be provided")
            if not os.path.isfile(ssl_certfile):
                raise IOError(
                    "The provided SSL certificate file doesn't exist")
            if not os.path.isfile(ssl_keyfile):
                raise IOError("The provided SSL key file doesn't exist")
            self.ssl_keyfile = ssl_keyfile
            self.ssl_certfile = ssl_certfile

    def register_worker(self):
        """
        Authenticates the worker

        Returns
        -------

        int:
            The id of the new client.
        """
        worker_data = request.json
        auth_success, auth_type = \
            self.worker_authenticator.authenticate_worker(worker_data[PUBLIC_KEY_STR],
                                                          worker_data[SIGNED_PHRASE])
        if auth_success:
            logger.info(
                f"Successfully registered worker with public key: {worker_data[PUBLIC_KEY_STR]}")
            if auth_type == NO_AUTHENTICATION:
                worker_id = hashlib.sha224(str(time.time()).encode(
                    'utf-8')).hexdigest() + '_unauthenticated'
            else:
                worker_id = worker_data[PUBLIC_KEY_STR]
            if worker_id not in self.worker_list:
                self.worker_list.append(worker_id)
        else:
            logger.info(
                f"Failed to register worker with public key: {worker_data[PUBLIC_KEY_STR]}")
            worker_id = INVALID_WORKER

        self.register_worker_callback(worker_id)
        return worker_id

    def receive_worker_update(self):
        """
        This receives the update from a worker and calls the corresponding callback function.
        Expects that the worker_id and model-update were sent using the DCFWorker.send_model_update()

        Returns
        -------

        str:
            If the update was successful then "Worker update received"
            Otherwise any exception that was raised.
        """
        try:
            compressed_model = request.files[ID_AND_MODEL_KEY].file.read()
            uncompressed = zlib.decompress(compressed_model)
            data_dict = pickle.loads(uncompressed)

            if data_dict[WORKER_ID_KEY] in self.worker_list:
                return_value = self.receive_worker_update_callback(
                    data_dict[WORKER_ID_KEY],
                    data_dict[MODEL_UPDATE_KEY]
                )
                return return_value
            else:
                logger.warning(
                    f"Unregistered worker {data_dict[WORKER_ID_KEY]} tried to send an update.")
                return UNREGISTERED_WORKER
        except Exception as e:
            logger.warning(e)
            return str(e)

    def check_model_ready(self, body, last_worker_model_version):
        """
        Threaded function run to check with the server if the model is ready.

        Parameters
        ---------

        body: gevent.queue.Queue
            The Queue used to return the data to the calling worker and
            fulfill the WSGI promise/map.

       last_worker_model_version: object
            The version of the last model that the worker was using.
        """
        while self.is_global_model_most_recent(last_worker_model_version):
            gevent.sleep(self.model_check_interval)

        model_update = self.return_global_model_callback()
        if not is_valid_model_dict(model_update):
            logger.error(f"Expected dictionary with {GLOBAL_MODEL} and {GLOBAL_MODEL_VERSION} keys - "
                         "return_global_model_callback() implementation is incorrect")
        body.put(zlib.compress(pickle.dumps(model_update)))
        body.put(StopIteration)

    def return_global_model(self):
        """
        Returns the global model by using the provided callback using gevent
        based long polling. It spawns a gevent Greenlet (a pseudo-thread) for
        check_model_ready, which returns a model when ready, but otherwise
        waits.

        Returns
        -------

        gevent.queuue.Queue or str:
            The Queue object that returns the model in a long polling or
            a string indicating an error has occured.
        """
        try:
            query_request = request.json
            if query_request[WORKER_ID_KEY] in self.worker_list:
                body = gevent.queue.Queue()
                g = Greenlet.spawn(self.check_model_ready, body, query_request[LAST_WORKER_MODEL_VERSION])
                return body
            else:
                return UNREGISTERED_WORKER
        except Exception as e:
            logger.warning(e)
            return str(e)


    @staticmethod
    def enable_cors():
        """
        Enable the cross origin resource for the server.
        """
        bottle.response.add_header('Access-Control-Allow-Origin', '*')
        bottle.response.add_header('Access-Control-Allow-Methods',
                                   'GET, POST, PUT, OPTIONS')
        bottle.response.add_header('Access-Control-Allow-Headers',
                                   'Origin, Accept, Content-Type, X-Requested-With, X-CSRF-Token')

    def start_server(self, server_adapter=None):
        """
        Sets up all the routes for the server and starts it.

        server_backend: bottle.ServerAdapter (default None)
            The server adapter to use. The default bottle.WSGIRefServer is used if none is given.
            WARNING: If given, this will over-ride the host-ip and port passed as parameters to this
            object.
        """
        application = Bottle()
        application.route(f"/{REGISTER_WORKER_ROUTE}",
                          method='POST', callback=self.register_worker)
        application.route(f"/{RETURN_GLOBAL_MODEL_ROUTE}",
                          method='POST', callback=self.return_global_model)
        application.route(f"/{RECEIVE_WORKER_UPDATE_ROUTE}",
                          method='POST', callback=self.receive_worker_update)

        application.add_hook('after_request', self.enable_cors)

        if server_adapter is not None and isinstance(server_adapter, ServerAdapter):
            self.server_host_ip = server_adapter.host
            self.server_port = server_adapter.port
            run(application, server=server_adapter, debug=self.debug, quite=True)
        elif self.ssl_enabled:
            run(application,
                host=self.server_host_ip,
                port=self.server_port,
                server='gunicorn',
                worker_class='gevent',
                keyfile=self.ssl_keyfile,
                certfile=self.ssl_certfile,
                debug=self.debug,
                quiet=True)
        else:
            run(application,
                host=self.server_host_ip,
                port=self.server_port,
                server='gunicorn',
                worker_class='gevent',
                debug=self.debug,
                quiet=True)


class WorkerAuthenticator(object):
    """
    Helper class for authenticating workers.

    Parameters
    ----------

    key_list_file: str
        The name of the file containing the public keys for valid workers.
        The file is a just list of the public keys, each generated by the
        worker_key_pair_tool tool. All workers are accepted if no workers
        are provided.
    """

    def __init__(self, key_list_file):
        if key_list_file is None:
            logger.warning(f"No key list file provided - "
                           f"no worker authentication will be used!!!.")
            logger.warning(f"Server is running in ****UNSAFE MODE.****")
            self.authenticate = False
            return

        with open(key_list_file, 'r') as f:
            keys = f.read().splitlines()

        # dict for efficient fetching of the public key
        self.authenticate = True
        self.keys = {key: VerifyKey(
            key.encode(), encoder=HexEncoder) for key in keys}

    def authenticate_worker(self, public_key_str, signed_message):
        """
        Authenticates a worker with the given public key against the
        given signed message.

        Parameters
        ----------

        public_key_str: str
            UFT-8 encoded version of the public key

        signed_message: str
            UTF-8 encoded signed message

        Returns
        -------

        bool:
            True if the public key matches the singed messge
            False otherwise
        """
        if not self.authenticate:
            logger.warning("Accepting worker as valid without authentication.")
            logger.warning(
                "Server was likely started without a list of valid public keys from workers.")
            return True, NO_AUTHENTICATION
        try:
            if public_key_str not in self.keys:
                return False, AUTHENTICATED
            self.keys[public_key_str].verify(
                signed_message.encode(), encoder=HexEncoder)
        except BadSignatureError:
            logger.warning(
                f"Failed to authenticate worker with public key: {public_key_str}.")
            return False, AUTHENTICATED
        else:
            logger.info(
                f"Successfully authenticated worker with public key: {public_key_str}.")
            return True, AUTHENTICATED
